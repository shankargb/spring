RESTFul Services
=================
REST stands for 'Representation State Transfer'

RESTFul services are used to develop Distributed Application

If one application is communicated with another application then those are called as 'Distributed Apps'

Interoperability means irrespective of the platform and language applications can communicated

             Java App  <----------------------> .Net App 
             .Net App  <----------------------> Python App
             Python App <---------------------> Java App

Distributed Applications are used for B 2 B communications 

B2B means Business to Business Communication 

Distributed Application will re-use services of one application in another application 

RESTFul services are providing 'Interoperability'

Two Actor's will be involved in Distributed Applications development 
     
          1. Provider 
          2. Consumer 

The application which is providing business services is called as Provided Application 

The application which is accessing business services is called as Customer Application 

distributed-app.png
###################

Note: One Provider application can have multiple consumer applications

Provider And Consumer will communicate using HTTP as a mediator 

Provider and Consumer will exchnage the data in Text/XML/JSON format 

Note: In Industry we will use JSON format to exchange data from one application to another application

C&P.jpg
#######

To start our journey with RESTFul services development we should be good in below areas.

1. HTTP Protocol(Methods, Status Codes, Req Structure & Res Structure)
2. XML and JAX-B API 
3. JSON and Jackson API 

What is HTTP:
-------------
HTTP stands for Hyper Text Transfer Protocol 

It act as a mediator between client & server(Consumer & Provider)

Consumer application will send HTTP Req to Provider application 

Provider application will process the request and will send HTTP response to Consumer 

HTTP Methods:
-------------
HTTP methods are used to send request from Consumer application to Provider application 

HTTP method will represent what type of operation client/consumer wants to perform with Provider

GET
POST
PUT 
DELETE 

GET request is used to retrieve dat from Provider application 
GET request will not have body 
To send any data from consumer using GET request then we will use Path Params & Query Params

Note: Path Params & Query Params data will be displayed in the URL
      It is not recommended to send sensitive / secret data using Path Params & Query Params

GET request is Idempotent(means if you send same GET request for multiple times aslo nothing will change at server)

POST request is used to create a new record at server 
When consumer wants to send huge data/sensitive data then Consumer will use POST request 
POST request contains request body 
POST request is Non-Idempotent

Note: In POST request we can send in URL and in Request Body 
      Request Body is the recommended approach to send sensitive data over server 

PUT request is used update a record at server 
When consumer wants to update a record at then consumer will send PUT request to Provider 
PUT request contains request body 
PUT request is Idempotent 

Note: In PUT request we can send in URL and in Request Body 
      Request Body is the recommended approach to send sensitive data over server 

DELETE request is used to delete a record at server 
DELETE request contains request body 
DELETE request is Idempotent

Note: In PUT request we can send in URL and in Request Body


HTTP Request Structure:
-----------------------
1. Initial Request Line(HTTP method + URL)
2. Request Headers(key-value)
3. Blank Line to seperate Header & Body 
4. Request Body(Request Payload)

HTTP Response Structure:
------------------------
1. Initial Request Line(Protocol Version + Status Code + Status Msg)
2. Request Headers(key-value)
3. Blank Line to seperate Header & Body 
4. Request Body(Response Payload)


HTTP Status Codes:
------------------
HTTP Status Codes will represent how the request process by server / provider 

1xx(100-199) ===> INFO 
2xx(200-299) ===> OK(success)
3xx(300-399) ===> Redirect 
4xx(400-499) ===> Client Error 
5xx(500-599) ===> Server Error

HTTP-Req-Res.png

XML 
====
XML stands for Extensible Markup Language 

XML is free and open source

XML is interoperable(Language independent & Platform Independent)

XML we can use to transfer data from one application to another application 

XML introduced by w3c org 

The initial version of xml is 1.0 and the current version of xml is also 1.0 

XML will represent data in the form of elements 

An element is the combination of start tag and end tag 
    Ex: <name>Sudha RealTime</name>

We will have 2 types of elements in the XML 

1. Simple Element 
2. Compound Element 

The element which contains data directly is called as Simple Element 
    <name>Sudha RealTime</name>
    <type>Educational</type>

The element which contains child element is called as Compund Element 
    <person>
       <id>101</id>
       <name>Ram</name>
    </person>

Note: Here <person> is compound element and <id><name> are simple elements 

We can have attribute also for the element 
     <student branch="CSE">
         <id>101</id>
         <name>Ram</name>
     </student>

Note: XML should have only one root element. Inside the root element we can have multiple child elements.

<persons>
     <person>
       <id>101</id>
       <name>Ram</name>
    </person> 
     <person>
       <id>102</id>
       <name>Sam</name>
    </person>  
</persons>    


JAX-B
======
JAX-B stands for Java Architecture for XML Binding 

JAX-B is use dto convert Java Object to xml and xml to java object 

JAX-B is free and open source 

JAX-B given by sun microsystems 

JAX-B is part of JDK upto 1.8v 

If you are using JDK1.8+ version of java then need to add JAX-B dependency in pom.xml 

The process of converting Java Obj into xml is called as "Marshalling"

The process of converting xml into Java obj is called as "Un-Marshalling" 

To perform Marshalling and Un-Marshalling we need to design Binding Classes 

The java class which represents the structure of XML is called as Binding class 

JAX-B provided annotations to represent java class as Binding class.

Note: Binding Class creation is one time operation 

Note: Earlier people used to create Binding Classes using XSD. XSD represents structure of xml.

@XmlAccessorType(XmlAccessType.FIELD): Controls marshalling and un-marshalling using fields of entity class 

@XmlAccessorOrder: Follow order of variables in the class to marshall and un-marshall 

@XmlElement(name="PhoneNum"): It is used to change the name of element 

@XmlAttribute: It represents variable as attribute in xml 

@XmlTransient: To skip a variable in marshalling

Note: By default every variable will be considered as Element and variable name will be considered as element name.


JSON
=====
JSON stands for Java Script Object Notation 

JSON will represent data in key-value format 
  Ex: 
       {
        "id": 4646,
        "name": "Ram Charan",
        "Profession": "Actor"
       }

JSON is interoperable(Language in-dependent & platform independent)

JSON is light weight 

JSON is both human readable and machine readable format

In today's world people are using JSON format to exchange data in B2B communications 

Now a days JSON is having more demand than XML beacuase of its simplicity and light weight


--->XML represents data in tags format(open tag & closed tag)
--->Meta data will be more than actual data in XML 
--->XML occupies more memory to represent data 

--->JSON will take less memory 
--->JSON islight wight 

--->To work with JSON data in Java Applications we have below 3rd party APIs 

1. JACKSON API
2. GSON API 

By using above apis we can convert JSON data to Java Object and vice versa  

The process of converting Java object into JSON is called as Serialization 

The process of converting JSON data to JAva Object is called as De-Serialization


Working with GSON API:
----------------------
1. Create a maven project with below dependency 
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.9.0</version>
    </dependency>   

GSON api provided by google 

In GSON api we have 'Gson' class to perform conversions 
 
      toJson() -> to convert java object to JSON 
      fromJson() -> to convert json data to java object

jackson json.png 

What is Distributed Application 
What is Interoperability 
What is HTTP Protocol 
HTTP Methods 
HTTP Status Codes 
HTTP Request Structure 
HTTP Response Structure 
Working with XML and JAX-B 
Working with JSON and Jackson



How to develop REST API 
=======================
To develop RESTFul services/REST API using java SUN Microsystem release 'JAX-RS' API.

JAX-RS api having two implementations 
     Jersey(SUN Microsystems)
     REST Easy(JBOSS)

Note: We can develop RESTFul Services using any one of the above implementation 

Spring framework also provided support to develop RESTFul Services using Spring Web MVC module



REST API Architecture 
---------------------
We will have 2 actors in RESTFul services 
     1. Provider / Resource 
     2. Consumer / Client 

The application which is providing services to other applications is called as Provider or Resource application 

The application which is accessing services from other applications is called as Consumer or Client application

Client application and Resource application will exchange data in interoperable format(like XML & JSON) 

                                             request
                         client app    <------------------->  resource app 
                                             response

Note: RESTFul Services are used to develop B2B communications(No presentation logic, No view Resolver)


Develop First REST API using Spring Boot 
----------------------------------------

1. Create Spring starter application with below dependencies 
      
             a)web-starter 
             b)devtools 

2. Create RestController with required methods 

Note: To represent java class as Rest Controller we will use @RestController annotation 

              @RestController = @Controller + @ResponseBody

Note: Every RestController method should be binded to HTTP Protocol method 

       @GetMapping @PostMapping @PutMapping @DeleteMapping 

3. Run the application and test it 

Note: Totest REST APIs we will use POSTMAN tool

Note: download postman tool to test our REST API functionality

Note: GET Request will not contain Request Body to send data 

We can use Query Params and Path Params to send data in GET Request 

Query Params & Path Params will represent data in URL directly 

Query Params 
------------
Query Params are used to send data to server in URL 

Query Params will represent data in key-value format 

Query Params will start with '?'

Query Parameters will be seperated by '&'

Query Parameters should present only at the end of the URL 
      Ex: www.sudha.tech/courses?name=SBMS&trainer=Sudha

To read Query Parameters from the URL we will use @RequestParam annotation 


Path Parameter or URI Variables 
--------------------------------
Path Parameters are also used to send data to server in URL 

Path Params will represent data directly in URL(no keys)

Path Params can present anywhere in the URL 

Path Params will be seperated by / (slash)

Path Params should be represented in Method URL pattern (Template Pattern)

         Ex: http://localhost:5656/course/{cname}/trainer/{sudha}

To read Path Parameters we will use @PathVariable annotation


Q)when to use Path Params & Query Params?
------------------------------------------
To retrieve more than one record/reosurce we will use Query Params(Filtering) 

To retrieve specific/unique record we will use Path Params(single)


What is Produces 
----------------
"produces" is a media type 

It represents the response formats supported by REST Controller Method 

One Rest Controller method can support multiple response formats(xml and json) 

Client Should send a request with "Accept" http header 

Accept header represents in which format client expecting response 

Based on Accept header value Message Converter will convert the response into client expected format 

Produce-xml-json.png


Working with HTTP POST Request 
------------------------------
HTTP POST request is used to create new resource/record ar server 

POST request contains request body 

Client can send data to server in Request Body 

To bind Rest Controller method to POST request we will use @PostMapping 

To read data from Request Body we will use @RequestBody annotation 

"consumes" represents in which formats method can take input 

"Content-Type" header represents in which format client sending data in request body 


produces vs consumes 
 ===>produces attribute represents in which formats Method can provide response data to clients 
 ===>consumes attribute represents in which formats Method can take request data from clients 

Content-Type vs Accpet 
 ===>Accept header represents in which format client expecting response from REST API
 ===>Content-Type header represents in which format client is sending request data to REST API 


 Requirement: Develop IRCTC REST API to book train ticket 
 ========================================================
 To develop any REST API first we ahve to unserstand the requirement 

 Identify input/request data 

 Identify output/response data 

 Create request & response binding class 

 Create REST Controller with required methods

 Test REST API methods behaviour using Postman


 HTTP PUT Request 
 ----------------
 PUT request is used to update an existing record/resource at server 

 PUT request can take data in URL and in Request Body 

 To bind our method to PUT request we will use @PutMapping 


 HTTP DELETE Request 
 -------------------
 DELELTE request is used to delete an existing record/resource at server 

 DELETE request can take data in URL and in Request Body 

 To bind our method to DELETE request we will use @DeleteMapping


What is RestController?
REST Controller Methods 
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping

Query Params 
Path Params 
@RequestParam 
@PathVariable 

produces 
consumes 
Accept 
Content-Type

Message Converters 

ResponseEntity

Q)Can we write the logic to update the data in POST requset method?
  Yes, we can do it but not recommended. We need to follow HTTP Protocol standars while developing REST API.


Swagger
=======
Swagger is used to generate documentation for REST APIs 

Swagger UI is used to test REST API with user interface

We can access swagger ui using below URL
    http://localhost:5656/swagger-ui/index.html#/

We can access swagger documentation using below url
        /v3/api-docs    

CRUD Operations using REST API with MYSQL DB 
---------------------------------------------
Download and install MySQL Database(DB Server)

Download & install MySQL Workbench(DB Client)

                          SQL Queries
              DB Client --------------> DB Server

Develop REST API using Layered Architecture 
        1. Web Layer 
        2. Business / Service Layer 
        3. DAO Layer 



Embedded Database(H2):
----------------------
Embedded Databases are temporary databases / in-memory databases

Embedded Databases are used for POC development (Proof of Concept)

We no need to download and install embedded databases 

Embedded Databases will come along with application by adding on dependency 

When we start application then emdedded db will start and when we stop the application then embedded db will be stopped 

Note: Data is not permenent in the embedded db (when we stop the application we will loose the data)

Note: In Memory DBs are not used for SIT,UAT,PROD environments in the company 

We can use H2 DB as an in-memory db for practice purpose

Our REST API running in a server that server is running in local machine thats why we can access only in our local
(it is not available for public access)

To provide oublic access for our REST API we need to redeploy that into cloud platform 

We have several cloud platforms in the market 

AWS 

Azure 

Gcp 

VM Wave 

Heroku : Heroku cloud Providing Platform As a Service to run our applications(PaaS)
         Heroku cloud Platform provided by Salesforce cloud company

App Deployment usingHeroku Setup:
=================================
Download Heroku CLI software 

Login Into Heroku using CLI(command prompt)
      $heroku login 

Note: It will open browser to login 

From cmd navigate to project folder 
    $ cd <project-location>

Execute below commands to deploy our code into heroku cloud 
    $git init 
$ heroku git:remote -a <heroku-app-name>

$ git add 

$ git commit -am "make it better"

$ git push heroku master 

Once deployment success we can access our application from browser(click on Open App button)


How to deploy Spring Boot App in AWS Cloud 
==========================================
Create free tier account in AWS 

Launch EC2 Linux Virtual Machine in AWS Cloud 

Connect to EC2 Linux VM using MobaXterm / Putty 

Upload our Spring Boot Jar file into EC2 VM 

Install Java software in EC2 VM 

Run the Java application in EC2 VM

Access the application browser


REST Client
===========
The application which is accesing REST API is called as REST Client.

Rest Client app and REST api application will communicate using HTTP as a mediator.

Every Programming language having support to develop REST Client

Using Spring Boot also we can develop REST Client 


1. RestTemplate 
2. WebClient

RestTemplate is a predefined class, which is part of 'spring-boot-starter-web' dependency. It supports only sychronous communication.

WebClient is a interface which is part of 'spring-boot-starter-webflux' dependency. It supports both synchronous and asynchronous communication.

Note: To develop REST Client we need to know REST API details

1. API URL
2. API Request Method
3. API Request data structure
4. API response data structure

REST API team will send swagger documentation to REST Client side team. Using swagger documentation we need to understand the api and we need to know 
to develop REST Client logic to access REST API.

 RestTemplate Example to access REST API
 =======================================
    String apiUrl = "https://";
    
    RestTemplate rt = new RestTemplate();

    ResponseEntity<String> forEntity = rt.getForEntity(apiUrl,String.class);

    String body = forEntity.getBody();

    System.out.println(body);

****************Sending HTTP GET Request using Rest Template**************
public void invokeGetBooksOld() {
		String url = "http://localhost:5656/getall/book";

		RestTemplate rt = new RestTemplate();
		ResponseEntity<String> getEntity = rt.getForEntity(url, String.class);
		String body = getEntity.getBody();
		System.out.println(body);
	}

***************Sending HTTP POST Request using Rest Template*************
@Service
public class BookClient {

	public void invokeBookTicket() {

		Book book = new Book();
		book.setBookName("Java");
		book.setBookPrice(345.00);

		String url = "http://localhost:5656/save/book";

		RestTemplate rt = new RestTemplate();
		ResponseEntity<String> postForEntity = rt.postForEntity(url, book, String.class);
		System.out.println(postForEntity.getBody());
	}
}

************Sending GET Request and binding Response JSON to binding Obj****************************
public void invokeGetBooksNew() {
		String url = "http://localhost:5656/getall/book";

		RestTemplate rt = new RestTemplate();
		ResponseEntity<Book[]> getEntity = rt.getForEntity(url, Book[].class);
		Book[] books = getEntity.getBody();
		for (Book book : books) {
			System.out.println(book);
		}
	}



What is Synchronous & Asynchronous
==================================
Syncronous means blocking the thread until we get response

Asynchronous means non-blocking thread 

Rest Template supports only Synchronous communications.

WebClient supports both Sync & Async communications 

WebClient introduced in Spring 5.x version

WebClient is part of WebFlux starter 


GET: http://localhost:5656/getall/book

POST: http://localhost:5656/save/book


HTTP Post Request with WebClient 
=================================
public void invokeSaveBook() {

		Book book = new Book();
		book.setBookName("SpringBoot");
		book.setBookPrice(600.00);

		String url = "http://localhost:5656/save/book";

		WebClient client = WebClient.create();

		String resp = client.post().uri(url).bodyValue(book).retrieve().bodyToMono(String.class).block();
		System.out.println(resp);
	}

HTTP GET Request with WebClient 
================================
public void invokeGetBooks() {
		String url = "http://localhost:5656/getall/book";

		WebClient client = WebClient.create();

		/*
		 * String block = client.get() // GET request .uri(url) // Endpoint url
		 * .retrieve()// retrieve response body .bodyToMono(String.class) // bind
		 * response data .block(); // make it sync
		 */

		Book[] responseData = client.get().uri(url).retrieve().bodyToMono(Book[].class).block();
	
		for(Book book:responseData) {
			System.out.println(book);
		}
	}

HTTP GET Request with WebClient Asynch call
===========================================
public void invokeGetBooksAsync() {
		String url = "http://localhost:5656/getall/book";

		WebClient client = WebClient.create();

	   client.get().uri(url).retrieve().bodyToMono(Book[].class).subscribe(BookClient::respHandler);
		
		System.out.println("******Request Sent*************");
		
	}
public static void respHandler(Book[] books) {
		for(Book book:books){
			System.out.println(book);
		}
	}


application.properties file VS application.yml file
====================================================

When we create spring boot application by default application.properties will be created.

We can avoid hard coded values by consfiguring app properties in this application.properties file

Properties file will represent data in key-value format

Ex: 
   server.port=9898
   spring.mvc.view.prefix=/views/
   spring.mvc.view.suffix=.jsp

properties file will represent data in sequential format

.properties file will be supported by only java

For every profile we need to create separate properties file

******As an alternate to .properties we can use .yml file in springboot********

YML stands YET ANOTHER MARKUP Language

YML represents data in hierarchical format

server:
 port:2372

YML supports key-value,list and map values also

YML supportsed by other programming languages also

All the profiles can be configured in single YML file


Working with Dynamic Properties
===============================
application.properties
--------------------
server.port=2323

welcome.msg = Welcome to Spritn App

@RestController
public class WelcomeController {
	
	@Value("${welcome.msg}")
	private String msg;

	@GetMapping("/")
	public String welcomeMsg() {
		return msg;
	}
}

application messages and REST Endpoint URLs are not recommended to hardcoded in java classes. Because if we change any message or any 
url then we have to compile and package entire application.

To avoid this problem we will configure messages and URLs in application.properties file o in application.yml file

When we change application.properties file or application.yml file we no need to compile and build entire project.


Working with App Properties
===========================

server:
 port: 4774
 
spring:
 application:
    name: sb-yml-app
    
sudhatech:
 messages:
  welcomeMsg: Welcome to SudhaTech   
  greetMsg: Good Morning 
  wishMsg: All the best 

@Configuration
@EnableConfigurationProperties
@ConfigurationProperties(prefix="sudhatech")
public class AppProperties {

	private Map<String, String> messages = new HashMap<>();

	public Map<String, String> getMessages() {
		return messages;
	}

	public void setMessages(Map<String, String> messages) {
		this.messages = messages;
	}

} 
    
@RestController
public class DemoRestController {

	@Autowired
	private AppProperties props;

	@GetMapping("/welcome")
	public String welcomeMsgMethod() {
		return props.getMessages().get("welcomeMsg");
	}
	
	@GetMapping("/greet")
	public String greetMsgMethod() {
		return props.getMessages().get("greetMsg");
	}

	@GetMapping("/wish")
	public String wishMsgMethod() {
		return props.getMessages().get("wishMsg");
	}

}      


Spring Boot Actuators
======================

Actuator is one of the powerful feature introduced in Spring Boot 

Actuators are used to monitor and manage our application 

Actuators are giving Production ready features our boot application 


Actuators  Endpoints
--------------------

/health: To get application health status 

/info: To get application information 

/beans: To get what beans loaded by our application 

/mappings: To get what URL patterns available in our application 

/configProps: To get configuration properties loaded by our application.

/heapdump: To download heap data 

/threaddump: To get threads information

/shutdown: To stop application (This is special, it is bind to POST request)

====> To work with actuators we have to use 'spring-boot-starter-actuator' dependency

        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>

/health is a default endpoint which we can access directly

We can see actuator exposed endpoints using below URL 
    
	     URL: http://localhost:3382/actuator

We can expose other actuator endpoints using below property
 
      management:
	   endpoints:
	    web:
		 exposure:
		  include: '*'

management.endpoints.web.exposure.include= *
management.endpoints.web.exposure.exclude= beans

Working with shutdown
=====================
It is used to stop our application 
We need to enable this manually
It is binded to http post request

management:
 endpoints:
  exposure:
   include: '*'
 endpoint:
  shutdown:
   enabled: true
